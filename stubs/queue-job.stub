{{{
  exports({
    to: app.makePath('app/jobs', entity.path),
    pattern: 'snakecase',
    suffix: '_job.ts'
  })
}}}
import { Dispatchable } from '@hschmaiske/jobs'
import { inject } from '@adonisjs/core'
import Logger from '@adonisjs/core/services/logger'

export interface {{ entity.name }}Payload {
  // Define your job payload structure here
  // Example:
  // userId: string
  // email: string
}

@inject()
export default class {{ entity.name }}Job extends Dispatchable {
  /**
   * Required: Path for dynamic imports
   * This allows the job system to properly load your job
   */
  static get $$filepath() {
    return import.meta.url
  }

  // Optional: Specify custom queue (autocomplete enabled if declared in config)
  // If not specified, uses defaultQueue from config (default: 'default')
  // static queue = 'emails'
  
  // Optional: Override auto-generated job name
  // static jobName = 'custom-job-name'
  
  // Optional: All pg-boss work options in one object
  // static workOptions = {
  //   batchSize: 10,        // Process jobs in batches
  //   teamSize: 5,          // Worker concurrency  
  //   priority: 10,         // Higher = more important
  //   retryLimit: 5,        // Max retry attempts
  //   retryDelay: 60,       // Seconds between retries
  //   expireInHours: 2,     // Job expiration
  // }

  constructor(private logger: Logger) {
    super()
  }
  
  async handle(payload: {{ entity.name }}Payload) {
    // Implement your queue job logic here
    this.logger.info('Processing {{ entity.name | camelCase }} job', payload)
    
    // Example: Process the job
    // await someService.processData(payload)
    
    // Return success (job will be marked as completed)
    // Throw an error to mark job as failed and trigger retry
  }
}